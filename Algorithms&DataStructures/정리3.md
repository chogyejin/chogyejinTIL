# 재귀(Recursion)

- 자기 자신을 호출하는 과정
  - 호출 스택에 계속 쌓임
  - 나중에 호출된 게 먼저 return 됨
  - Chrome의 Source 탭에서 호출 스택 디버깅 가능
- 어디에 쓰이나?
  - `JSON.pares`, `JSON.stringify`
  - `document.getElementById`, DOM 순회(traversal) 알고리즘
  - 객체 순회
  - 때때로 반복문보다 더 깔끔하게 쓰임
- 어떤 게 필요한가?

  - 종료 조건(base case) (if + return)
  - 다른 입력(different input)

- 간단 예시

```js
// 5 입력되면 5, 4, 3, 2, 1 끝
function countDown(num) {
  if (num <= 0) {
    console.log("끝");
    return;
  }
  console.log(num);
  num--;
  countDown(num);
}
```

## Helper Method Recursion

- 함수 내부에서 재귀 함수를 사용

  - 재귀 내부에서 변수(보통 배열)가 초기화 되지 않도록 하기 위함

- 예시

```js
// 배열에서 홀수만 구하기
function collectOdds(arr) {
  const result = [];

  function helper(helperArr) {
    if (helperArr.length === 0) {
      return;
    }

    if (helperArr[0] % 2 !== 0) {
      result.push(helperArr[0]); // 홀수면 result에 push
    }
    helper(helperArr.slice(1)); // 1번 인덱스 이후
  }
  helper(arr);

  return result;
}
```

## Pure Recursion

- 순수 재귀, 자체로 결과값 반환
  - 문자열이라면 `slice`, `substr`, `substring` 사용
  - 배열이라면 `slice`, `concat`, spread operator 사용
  - 객체라면 `Object.assign`, spread operator 사용
- 예시

```js
function collectOdds(arr) {
  let newArr = []; // 매 호출마다 초기화

  if (arr.length === 0) {
    return newArr; // 맨마지막 호출 때 빈 배열 return
  }

  if (arr[0] % 2 !== 0) {
    newArr.push(arr[0]);
  }

  // 홀수일 때 => [홀수].concat()
  // 짝수일 때 => [].concat()
  newArr = newArr.concat(collectOdds(slice(1))); // 원소 1개 배열.slice(1)은 []

  return newArr;
}
```
