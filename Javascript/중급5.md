# Class(ES6에 추가)

- 클래스 내에 선언한 메서드는 만들어진 객체의 프로토타입에 저장됨.
  (생성자 함수는 객체 내부에 저장)
- 생성자 함수 이용했을 때 new 키워드 붙이지 않고 객체 만들면 undefined 반환, 클래스는 typeError 반환(constructor가 class임이 명시되어 있다.)
- 클래스 메서드는 for .. in 문에서 제외됨

```
class User {
    constructor(name,age){
        this.name = name;
        this.age = age;
    }
    showName(){
        console.log(this.name);
    }
}

const tom = new User("Tom",19);
```

- 클래스의 상속(extends)

  - 아래 예제에서 z4 객체에서 먼저 찾고, constructor가 class Bmw인 프로토타입에서 찾고, 다시 그 속의 constructor가 class Car인 프로토타입에서 찾는다.

- 메서드 오버라이딩
  - 같은 이름의 메서드가 있다면 Bmw 내에서 먼저 찾아서 실행, 부모에게 상속받은 메서드를 실행하고 싶다면 오버라이딩(overriding) 이용.(super.메서드명())

```
class Car {
    constructor(color){
        this.color = color;
        this.wheels = 4;
    }
    drive(){
        console.log("drive..");
    }
    stop(){
        console.log("STOP");
    }
}

class Bmw extends Car {
    park(){
        console.log("Park");
    }
    stop() {
        //super.stop(); //메서드 오버라이딩(method overriding)
        console.log("OFF");
    }
}

const z4 = new Bmw("blue");

//super.stop(); 있으면 z4.stop(); 실행 시 STOP, OFF 출력
```

- 생성자 오버라이딩

  - 클래스의 constructor는 빈 객체({})로 만들어지고 this로 이를 가리키게 됨. extends로 만들어진 자식 객체는 constructor 안에 super를 이용하여 부모의 constructor를 실행해줘야함.
  - z4 객체의 blue 인수를 제대로 넘기려면 constructor의 super의 매개변수(color) 를 통해 넘겨줘야함.

  ```
  constructor(color){
      super(color);
  }
  ```

# Promise

```
//resolve는 성공, reject는 실패 시 실행되는 함수
//callback 함수 : 어떤 일이 완료된 후에 실행되는 함수
const pr = new Promise((resolve, reject) => {
    //code
});
```
