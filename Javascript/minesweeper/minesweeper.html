<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>지뢰찾기</title>
    <style>
      table {
        border-collapse: collapse;
      }
      td {
        border: 1px solid #bbb;
        text-align: center;
        line-height: 20px;
        width: 20px;
        height: 20px;
        background: #888;
      }
      td.opened {
        background: white;
      }
      td.flag {
        background: red;
      }
      td.question {
        background: orange;
      }
    </style>
  </head>
  <body>
    <table id="table">
      <tbody></tbody>
    </table>
    <div id="result"></div>
    <script>
      const $tbody = document.querySelector("#table tbody");
      const $resutl = document.querySelector("#result");

      const row = 10;
      const cell = 10;
      const mine = 10;
      const CODE = {
        NORMAL: -1,
        QUESTION: -2,
        FLAG: -3,
        QUESTION_MINE: -4, // 지뢰가 있는데 물음표인 칸
        FLAG_MINE: -5, // 지뢰가 있는데 플래그인 칸
        MINE: -6,
        OPENED: 0,
      };
      let data;
      // 데이터를 만들고 화면을 수정하자

      function makeMine() {
        const numbers = Array(row * cell)
          .fill()
          .map((number, index) => index); // callback { return } 생략
        const shuffle = [];

        while (numbers.length > row * cell - mine) {
          // 랜덤으로 뽑은 1개 숫자 배열(splice)의 1번째 원소를 push
          const chosenNumber = numbers.splice(
            Math.floor(Math.random() * numbers.length), // 랜덤 index
            1
          )[0];
          shuffle.push(chosenNumber);
        }

        // 모두 일반칸으로 초기화
        const data = [];
        for (let i = 0; i < row; i++) {
          const rowData = []; // 행 배열
          for (let j = 0; j < cell; j++) {
            rowData.push(CODE.NORMAL);
          }
          data.push(rowData);
        }

        // shuffle 배열에 있는 칸에 지뢰 심기, 예시 들면서 생각하자 [76, 22, ...]
        for (let k = 0; k < shuffle.length; k++) {
          const line = Math.floor(shuffle[k] / row); // 0~9번째 줄, 10의 자리 숫자
          const th = shuffle[k] % cell; // 1의 자리 숫자
          data[line][th] = CODE.MINE;
        }
        return data;
      }

      function onRightClick(event) {
        event.preventDefault(); // 브라우저 우클릭 기본동작 제한
        console.log(event);
        console.log(event.target); // td
        console.log(event.target.value); // undefined
        console.log(event.target.textContent); // 공백이나 'X'
        console.log(event.target.parentNode); // tr
        console.log(event.target.parentNode.rowIndex); // 몇 번째 줄인지
        console.log(event.target.cellIndex); // 몇 번째 칸인지

        // 클릭 칸 데이터 찾기
        const rowIndex = event.target.parentNode.rowIndex;
        const cellIndex = event.target.cellIndex;
        const cellData = data[rowIndex][cellIndex];

        // 일반 칸(-1) > 물음표(-2) > 깃발(-3) > 일반 칸(-1)
        // 지뢰(-6) > 물음표 지뢰(-4) > 깃발 지뢰(-5) > 지뢰(-6)
        if (cellData === CODE.NORMAL) {
          data[rowIndex][cellIndex] = CODE.QUESTION;
          event.target.className = "question";
          event.target.textContent = "?";
        } else if (cellData === CODE.QUESTION) {
          data[rowIndex][cellIndex] = CODE.FLAG;
          event.target.className = "flag";
          event.target.textContent = "!";
        } else if (cellData === CODE.FLAG) {
          data[rowIndex][cellIndex] = CODE.NORMAL;
          event.target.className = "";
          event.target.textContent = "";
        } else if (cellData === CODE.MINE) {
          data[rowIndex][cellIndex] = CODE.QUESTION_MINE;
          event.target.className = "question";
          event.target.textContent = "?";
        } else if (cellData === CODE.QUESTION_MINE) {
          data[rowIndex][cellIndex] = CODE.FLAG_MINE;
          event.target.className = "flag";
          event.target.textContent = "!";
        } else if (cellData === CODE.FLAG_MINE) {
          data[rowIndex][cellIndex] = CODE.MINE;
          event.target.className = "";
          event.target.textContent = "X";
        }
      }

      function countMine(rowIndex, cellIndex) {
        const mines = [CODE.MINE, CODE.QUESTION_MINE, CODE.FLAG_MINE];
        // 8방향으로 지뢰 센다(optional chaining, 논리 연산자 이용)
        // 1, 2, 3, 4, 5(기준칸), 6, 7, 8, 9 순서
        let sum = 0;
        mines.includes(data[rowIndex - 1]?.[cellIndex - 1]) && sum++;
        mines.includes(data[rowIndex - 1]?.[cellIndex]) && sum++;
        mines.includes(data[rowIndex - 1]?.[cellIndex + 1]) && sum++;
        mines.includes(data[rowIndex][cellIndex - 1]) && sum++; // rowIndex 자체는 0~9 > undefined 안 됨
        mines.includes(data[rowIndex][cellIndex + 1]) && sum++;
        mines.includes(data[rowIndex + 1]?.[cellIndex - 1]) && sum++;
        mines.includes(data[rowIndex + 1]?.[cellIndex]) && sum++;
        mines.includes(data[rowIndex + 1]?.[cellIndex + 1]) && sum++;

        return sum;
      }

      function onLeftClick(event) {
        // event.target은 td 태그임
        // 칸이 열리거나 지뢰거나 둘 중 하나
        const rowIndex = event.target.parentNode.rowIndex;
        const cellIndex = event.target.cellIndex;
        const cellData = data[rowIndex][cellIndex];

        // 일반 칸이면 지뢰 세고
        if (cellData === CODE.NORMAL) {
          const count = countMine(rowIndex, cellIndex);
          event.target.className = "opened";
          event.target.textContent = count || ""; // count false면(0도 포함) 빈 문자열
          data[rowIndex][cellIndex] = count;
        }
        // 지뢰면 event remove까지
        else if (cellData === CODE.MINE) {
          event.target.className = "opened";
          event.target.textContent = "팡";
          $tbody.removeEventListener("click", onLeftClick);
          $tbody.removeEventListener("contextmenu", onRightClick);
        }
      }

      function makeTable() {
        data = makeMine();

        data.forEach((row) => {
          const $tr = document.createElement("tr");
          row.forEach((cell) => {
            const $td = document.createElement("td");
            if (cell === CODE.MINE) {
              // 개발자 편의를 위해 그려놓음
              $td.textContent = "X";
            }
            $tr.appendChild($td);
          });
          $tbody.appendChild($tr);
          $tbody.addEventListener("contextmenu", onRightClick); // 이벤트 버블링
          $tbody.addEventListener("click", onLeftClick);
        });
      }
      makeTable();
    </script>
  </body>
</html>

<!-- 
contextmenu 이벤트
브라우저에서 마우스 우클릭 이벤트로 기본 동작이 있다(복사, 인쇄, 검사 등)
여기선 우클릭으로 물음표나 깃발을 세울 것이기 때문에 preventDefault()로 기본 동작을 제한한다.

CODE 객체
화면은 같지만 다른 데이터(지뢰 혹은 지뢰 없는 칸)를 가질 수 있음.

optional chaining
?.은 ?.'앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환
undefined의 property를 접근하려 하면 에러나오기 때문에 이를 방지시켜준다.
2차원 배열에서 1차의 배열 원소가 확실하지 않을 땐 data[]?.[] 
위 countMine() 함수에서
기준칸의 왼쪽 대각선 위부터 오른쪽 대각선 아래까지 지뢰를 세는데 data 배열의 바깥에 접근하려 하면 에러 발생
이는 rowIndex가 음수가 되거나 세로 길이보다 커졌을 때 undefined인데 2차원 배열의 값을 찾으려하기 때문

논리 연산자, 널 병합 연산자(nullish coalescing)
A && B : A true면 B 실행
A || B : A false('', 0, false, NaN, null, undefined)면 B 실행
A ?? B : A가 null이나 undefined이면 B 실행(||보다 범위 작아짐)
 -->
