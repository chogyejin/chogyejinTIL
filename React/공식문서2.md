# [React 공식문서](https://ko.reactjs.org/docs/getting-started.html) 보며 몰랐던 부분 찾기

## ADVANCED GUIDES

### Accessibility(접근성)

- 모든 사용자가 사용할 수 있도록 웹사이트를 디자인, 개발해야함(보조과학기술(assistive technology)들이 웹페이지들을 해석할 수 있도록 접근성을 갖추는 것이 필요)
- 필요한 지침
  - [WCGA](https://www.w3.org/WAI/standards-guidelines/wcag/)
  - JavaScript 위젯 기술 [WAI-ARIA](https://www.w3.org/WAI/standards-guidelines/aria/)
    - JSX에서는 `aria-*` HTML attribute를 지원
- Semantic HTML
  - 정보의 의미가 강조되는 HTML 태그 사용하자
- Accessible Forms
  - 스크린 리더를 사용하는 사용자를 위해 설명이 담긴 label로 폼 컨트롤을 감싸야 함
    - [W3C의 라벨링](https://www.w3.org/WAI/tutorials/forms/labels/)
    - [WebAIM의 라벨링](https://webaim.org/techniques/forms/controls)
  - 스크린 리더에 오류 문구를 적절하게 노출시켜야 함
- Focus Control
  - 모든 웹 애플리케이션은 키보드만 사용하여 모든 동작을 할 수 있어야 함
  - `outline: 0`은 포커스 윤곽선을 교체할 때만 사용, 제거만 하는 것은 좋지 않다.
  - [Skip Navigation Link](https://webaim.org/techniques/skipnav/): 키보드 사용자가 페이지와 상호작용할 때만 표시되는 숨겨진 탐색 링크
  - [Accessible Landmarks](https://www.scottohara.me/blog/2018/03/03/landmarks.html): 랜드마크 엘리먼트를 통해 사용자 영역을 나눠야 함
  - 포커스 관리
    - 프로그래밍적으로 키보드 포커스를 올바른 방향으로 변경 필요(ex) 모달의 open close에 따라 reset)
    - 좋은 예시로 [react-aria-modal](https://github.com/davidtheclark/react-aria-modal)
- Mouse and pointer events
  - 마우스 혹은 포인터 이벤트로 노출된 모든 기능을 키보드만으로 사용할 수 있도록 보장해야 함
- Color contrast
  - 색 조합: [colorable](https://colorable.jxnblk.com/)
  - 색 채도 검사: [contrastchecker](https://webaim.org/resources/contrastchecker/)
- 개발 및 테스트 도구
  - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y): JSX 내 접근성 린팅, CRA에 일부 포함
  - aXe와 aXe-core, react-axe: 브라우저에서 접근성 테스트
  - 스크린 리더: Firefox의 NVDA, Safari의 VoiceOver, Internet Explorer의 JAWS, Google Chrome의 ChromeVox

### Code-Splitting

- 번들링: 여러 파일을 하나로 병합한 번들된 파일을 웹 페이지에 포함하여 한 번에 전체 앱을 로드(Webpack, Rollup, Browserify 등)
- 코드 분할(Code-Splitting): 규모가 커졌을 때 런타임에서 동적으로 번들을 불러와(`import()`) 성능 향상

```ts
// src/math.ts
export function add(num1: number, num2: number) {
  return num1 + num2;
}
```

```ts
// static import
import { add } from "./math";

console.log(add(16, 26));

// dynamic import
import("./math").then((math) => {
  console.log(math.add(16, 26));
});
```

- React.lazy + Suspense

  - `React.lazy()` 인자는 동적 import를 호출하는 함수(`() => import()`), export default 된 컴포넌트만 지원
  - `Suspense` 컴포넌트 하위에 lazy 컴포넌트를 넣어 기다리는 동안 fallback 컨텐츠를 보여줌

  ```js
  import React, { Suspense } from "react";

  const OtherComponent = React.lazy(() => import("./OtherComponent"));
  const AnotherComponent = React.lazy(() => import("./AnotherComponent"));

  function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <section>
            <OtherComponent />
            <AnotherComponent />
          </section>
        </Suspense>
      </div>
    );
  }
  ```

  - Avoiding fallback

    - Suspense와 tab으로 관리되는 컴포넌트에서 처음엔 fallback으로 `Glimmer`, 전환 시에 fallback을 감추고 전의 UI(`Photos`)를 유지하고 싶다면 `startTransition`으로 시간이 걸릴 수 있는 [transtion](https://ko.reactjs.org/docs/react-api.html#transitions)이라고 React에게 알림

    ```js
    import React, { Suspense } from "react";
    import Tabs from "./Tabs";
    import Glimmer from "./Glimmer";

    const Comments = React.lazy(() => import("./Comments"));
    const Photos = React.lazy(() => import("./Photos"));

    function MyComponent() {
      const [tab, setTab] = React.useState("photos");

      function handleTabSelect(tab) {
        startTransition(() => {
          setTab(tab);
        });
      }

      return (
        <div>
          <Tabs onTabSelect={handleTabSelect} />
          <Suspense fallback={<Glimmer />}>
            {tab === "photos" ? <Photos /> : <Comments />}
          </Suspense>
        </div>
      );
    }
    ```

  - Error Boundary로 lazy 컴포넌트를 감싸면 네트워크 장애가 발생했을 때 에러를 표시하여 사용자 경험을 향상시키고 recovery를 관리할 수 있다.

- Route-based code splitting

  - 사용자는 페이지 전환에 어느 정도 시간이 걸리는 것에 익숙하고, 전체 페이지를 한번에 re-render 하는 경향이 있기 때문에 사용자와 다른 요소가 상호 작용할 가능성이 낮음

  ```js
  import React, { Suspense, lazy } from "react";
  import { BrowserRouter as Router, Routes, Route } from "react-router-dom";

  const Home = lazy(() => import("./routes/Home"));
  const About = lazy(() => import("./routes/About"));

  const App = () => (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </Router>
  );
  ```

### Context

- 단계마다 일일이 props를 넘겨주지 않고도 컴포넌트 트리 전체에 데이터를 제공
- 언제 사용해야 하는지

  - 로그인한 유저, 테마, 선호하는 언어 등을 global하게 공유해야 할 때
  - context를 사용하면 컴포넌트의 재사용성이 떨어지기 때문에 반드시 필요할 때만 쓰고, 컴포넌트 합성(props로 컴포넌트를 직접 내림)도 해결책이 될 수 있다.
    - 제어의 역전(inversion of control)을 통해 코드가 깔끔해질 수는 있지만 그만큼 상위 컴포넌트가 복잡해진다.

- API
  - `React.createContext`
    - Context 객체 생성하는 메서드, Provider로부터 현재 값을 읽음
    - 인자로 전달하는 defaultValue는 적절한 Provider를 못 찾았을 때 사용하는 값(컴포넌트를 독립적으로 테스트할 때 유용)
  - `Context.Provider`
    - context의 변화를 알리는 컴포넌트
    - `value` prop을 전달하는데 이 context를 구독한 모든 하위 컴포넌트는 value가 바뀌면 전부 re-render
      - value가 객체일 때 불필요한 re-render에 유의(value를 Provider 부모의 state로 관리하여 해결)
  - `Class.contextType`
    - 클래스 컴포넌트에 context를 property로 지정, 클래스 안에서 this.context로 활용
  - `Context.Consumer`
    - 함수 컴포넌트 안에서 context 구독하는 컴포넌트
    - 자식이 함수여야 함, `<A.Consumer>{value => // ... }</A.Consumer>`
  - `Context.displayName`
    - React DevTools에서 사용할 문자열 지정
- 하위 컴포넌트에서 context 업데이트
  - context에 함수를 담아서 전달

### Error Boundary

- UI의 일부분에 존재하는 에러가 전체 애플리케이션을 중단시켜서는 안 됨, React 16에서 도입한 하위 컴포넌트 트리의 어디에서든 자바스크립트 에러를 기록하며 깨진 컴포넌트 트리 대신 fallback UI를 보여주는 React 컴포넌트, JavaScript의 `catch {}` 구문과 유사
- 포착하지 않는 에러

  - 이벤트 핸들러

    - try-catch 이용하자

    ```js
    handleClick() {
      try {
        //
      } catch (error) {
        this.setState({ error }); // render()에서 this.state.error에 따라 if로 분기
      }
    }
    ```

  - 비동기 코드
  - SSR
  - 에러 바운더리 자체 에러

- 사용 방법
  - 클래스 컴포넌트로 생명주기 메서드인 `static getDerivedStateFromError()` 와 `componentDidCatch()` 중 하나 혹은 둘 다를 정의
  - [예시](https://codepen.io/gaearon/pen/wqvxGa?editors=0010)
- 스택 추적
  - 컴포넌트 트리의 어느 부분에서 에러가 발생했는지 파일 이름과 줄 파악 가능
  - CRA가 아닐 땐 바벨 설정에 이 [플러그인](https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source) 추가 + Production 모드에선 비활성화 해야 함
- try-catch와의 비교
  - try-catch는 명령형(imperative) 코드, React 컴포넌트는 선언적(declarative) 코드

### Forwarding Refs

- 특정 컴포넌트의 자식 중 하나의 컴포넌트에 ref 전달하는 기법

  - 보통은 필요하지 않지만, 재사용성이 높은 leaf 컴포넌트에서는 캡슐화가 불편할 수 있다.

- ref 생성 > props 전달 > forwardRef 내부의 두 번째 인자로 전달 > button이 받기

```js
// forwardRef가 없으면 ref 받지 못하고 props에서도 사용 불가
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
// ref.current는 FancyButton의 button DOM
```

- Refs 전달 in HOC

  - `ref`는 `key`처럼 prop으로 전달이 불가능하고, HOC(HigherOorder Components)에 ref 전달하면 가장 바깥쪽 컨테이너 컴포넌트에 전달된다.

  ```js
  // logProps로 wrapping 된 컴포넌트에 ref를 전달하려고 해도 LogProps 컴포넌트에 전달됨
  function logProps(WrappedComponent) {
    class LogProps extends React.Component {
      componentDidUpdate(prevProps) {
        console.log("old props:", prevProps);
        console.log("new props:", this.props);
      }

      render() {
        return <WrappedComponent {...this.props} />;
      }
    }

    return LogProps;
  }
  ```

  ```js
  function A(props) {
    return <B />;
  }

  export default logProps(A); // createRef()하고 <A ref={ref} /> 해도 A에 ref 전달 안 됨
  ```

  - 해결 방법

  ```js
  function logProps(WrappedComponent) {
    class LogProps extends React.Component {
      // ...

      render() {
        const { forwardedRef, ...rest } = this.props;

        // forwardRef를 wrapping할 컴포넌트의 ref로 전달
        return <WrappedComponent ref={forwardedRef} {...rest} />;
      }
    }

    // React.forwardRef로 함수의 return부를 감싸고 forwardref로 받음
    return React.forwardRef((props, ref) => {
      return <LogProps {...props} forwardedRef={ref} />;
    });
  }
  ```

- React.forwardedRef가 받는 렌더링 함수에 익명의 화살표 함수 대신 함수 선언식을 이용하면 DevTools에 이름 표기 가능하다.

### Fragment

- DOM에 별도의 노드를 추가하지 않고 여러 자식을 그룹화
- key prop을 줘야 할 떄는 `<React.Fragment>`

### Higher-Order Components

- 컴포넌트 로직을 재사용하는 React의 패턴, 컴포넌트를 가져와 새 컴포넌트를 반환하는 **함수**
  - Redux의 `connect`, Relay의 `createFragmentContainer` 등
- 고차 컴포넌트는 side effect가 없는 순수 함수
- 원본 컴포넌트를 변형하지 말자 === HOC 함수 안에서 원본을 return 하는 일을 할 일이 없다.
  - prototype에 변형을 가하면 HOC가 override 됨에 유의
  - 변형(mutation) 대신 컨테이너 컴포넌트로 감싸자
- HOC와 컨테이너 컴포넌트의 차이

  - HOCs use containers as part of their implementation
  - 컨테이너는 자식과 관심사를 분리하는 것이고 state에 대한 관리를 하지 않는다. [링크](https://www.quora.com/What-is-the-difference-between-a-HOC-and-a-container-component-in-ReactJS)

- 주의사항
  - 클래스 컴포넌트의 render() 메서드 안에서 HOC 사용하지 말자
    - render 호출마다 HOC로 반환된 컴포넌트는 새롭게 생성되고, 해당 컴포넌트의 state와 children이 모두 소멸된다.
    - 컴포넌트 바깥에 HOC 적용하자
  - static method를 컨테이너 컴포넌트에 복사해두자 or method는 따로 export 하자

### JSX In Depth

- **React 17 이전**: JSX는 단순히 `React.createElement(component, props, ...children)`에 대한 syntactic sugar이다.

```jsx
// React와 MyButton import 해야 함
import React from "react";
import MyButton from "./MyButton";

function App() {
  return (
    <MyButton color="blue" shadowSize={2}>
      Click Me
    </MyButton>
  );
}
```

```js
// 컴파일 되면
React.createElement(
  MyButton, // component
  { color: "blue", shadowSize: 2 }, // props
  "Click Me" // ...children
);
```

- **React 17 이후**: 새로운 JSX 변환 방식([링크](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))

```js
function App() {
  return <h1>Hello World</h1>;
}
```

```js
// 컴파일 되면
// Inserted by a compiler === import 직접 안해도 됨
import { jsx as _jsx } from "react/jsx-runtime";

function App() {
  return _jsx("h1", { children: "Hello world" });
}
```

- Dot Notation

  - 나의 모듈에서 복수의 React 컴포넌트들을 export 하는 경우

  ```js
  const MyComponents = {
    DatePicker: function DatePicker(props) {
      return <div>Imagine a {props.color} datepicker here.</div>;
    },
  };

  function BlueDatePicker() {
    return <MyComponents.DatePicker color="blue" />;
  }
  ```

- user-defined component는 대문자로 시작, 아니면 built-in component로 인식함
- Choosing the Type at Runtime

  - prop에 따라 다른 컴포넌트 렌더하기

  ```js
  import { PhotoStory, VideoStory } from "./stories";

  const components = {
    photo: PhotoStory,
    video: VideoStory,
  };

  function Story(props) {
    // JSX type은 표현식(expression)이 될 수 없다.
    // return <components[props.storyType] story={props.story} />;

    //  대문자로 시작하는 변수는 JSX 타입으로 사용할 수 있습니다.
    const SpecificStory = components[props.storyType];
    return <SpecificStory story={props.story} />;
  }
  ```

- Props in JSX

  - `if` statement와 `for` loop은 JSX 밖 코드에 넣자

  ```js
  function NumberDescriber(props) {
    let description; // JSX 내에서 사용할 변수

    // props 이용하여 분기
    if (props.number % 2 == 0) {
      description = <strong>even</strong>;
    } else {
      description = <i>odd</i>;
    }
    return (
      <div>
        {props.number} is an {description} number
      </div>
    );
  }
  ```

- Props Default to “True”

```jsx
<MyTextBox autocomplete />
<MyTextBox autocomplete={true} />
```

- Spread Attributes
  - spread는 불필요한 prop을 컴포넌트에 넘기거나 유효하지 않은 HTML 속성들을 DOM에 넘기기도 함. 꼭 필요할 때만 사용하는 것을 권장

```js
const Button = (props) => {
  const { kind, ...other } = props; // other만 button에 내려줄 것임
  const className = kind === "primary" ? "PrimaryButton" : "SecondaryButton";
  return <button className={className} {...other} />;
};
```

- Children in JSX

  - `props.children`은 태그 사이의 값
  - 문자열 리터럴
    - JSX가 각 줄의 처음과 끝에 있는 공백, 빈 줄, 태그에 붙은 개행을 제거, 문자열 리터럴 중간에 있는 개행은 한 개의 공백으로 대체
  - 컴포넌트가 element로 이루어진 배열을 반환 가능, key 지정하자(`return []`)
  - 함수를 자식으로 사용

  ```js
  function Repeat(props) {
    let items = [];
    for (let i = 0; i < props.numTimes; i++) {
      items.push(props.children(i)); // props.children이 함수 하나임
    }
    return <div>{items}</div>;
  }

  function App() {
    return (
      <Repeat numTimes={10}>
        {(index) => <div key={index}>This is item {index} in the list</div>}
      </Repeat>
    );
  }
  ```

  - boolean, null, undefined
    - `true`, `false`, `null`, `undefined`는 렌더링 되지 않음(`<div />` === `<div>{true}</div>`)
      - 이 값들을 출력하려면 `String()` 이용
    - 이를 활용하여 boolean과 &&로 조건부 렌더링에 이용
    - `arr.length`이 0인 것과 같은 falsy한 값은 렌더링 될 수 있음에 유의 => `arr.length > 0`

### Optimizing Performance

- 성능 테스트는 production build로 하자
  - development에선 유용한 경고들이 있지만, React를 더 크고 느리게 만듦
  - CRA(Webpack): `npm run build`, build/ 에 빌드 파일 생성
  - 빌드 라이브러리
    - Brunch, Browserify, Rollup
- Virtualize Long Lists
  - 긴 배열은 [react-window](https://react-window.vercel.app/#/examples/list/fixed-size)와 [react-virtualized](https://bvaughn.github.io/react-virtualized/#/components/List) 등을 통해 `windowing` 기법을 적용하여 부분만 렌더링하자
- Avoid Reconciliation(재조정)
  - 컴포넌트의 prop이나 state가 변경되면 React는 새로 반환된 엘리먼트를 이전에 렌더링된 엘리먼트와 비교해서 실제 DOM 업데이트가 필요한지 여부를 결정
  - 눈에 띄게 렌더링 속도가 느리다면 shouldComponentUpdate 이용해보자([예제](https://www.geeksforgeeks.org/reactjs-shouldcomponentupdate-method/)), 렌더링 프로세스를 건너뛰게 할 수 있음
  - React.PureComponent도 사용 가능하지만, shallow comparison에서 제대로 동작하지 않을 수 있음에 유의
  - **_`concat`, spread syntax, `Object.assign` 등을 이용하여 기존 객체의 불변성을 지키면서 효과적인 상태 업데이트를 하고, 혹시 모를 사이드 이펙트를 방지한다._**
    - deeply nested objects에서 불변성을 지키고 싶다면 [Immer](https://github.com/immerjs/immer) 혹은 [immutability-helper](https://github.com/kolodny/immutability-helper)를 살펴보자

## API REFERENCE

## HOOKS

## TESTING

## 그 외
