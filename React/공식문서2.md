# [React 공식문서](https://ko.reactjs.org/docs/getting-started.html) 보며 몰랐던 부분 찾기

## ADVANCED GUIDES

### Accessibility(접근성)

- 모든 사용자가 사용할 수 있도록 웹사이트를 디자인, 개발해야함(보조과학기술(assistive technology)들이 웹페이지들을 해석할 수 있도록 접근성을 갖추는 것이 필요)
- 필요한 지침
  - [WCGA](https://www.w3.org/WAI/standards-guidelines/wcag/)
  - JavaScript 위젯 기술 [WAI-ARIA](https://www.w3.org/WAI/standards-guidelines/aria/)
    - JSX에서는 `aria-*` HTML attribute를 지원
- Semantic HTML
  - 정보의 의미가 강조되는 HTML 태그 사용하자
- Accessible Forms
  - 스크린 리더를 사용하는 사용자를 위해 설명이 담긴 label로 폼 컨트롤을 감싸야 함
    - [W3C의 라벨링](https://www.w3.org/WAI/tutorials/forms/labels/)
    - [WebAIM의 라벨링](https://webaim.org/techniques/forms/controls)
  - 스크린 리더에 오류 문구를 적절하게 노출시켜야 함
- Focus Control
  - 모든 웹 애플리케이션은 키보드만 사용하여 모든 동작을 할 수 있어야 함
  - `outline: 0`은 포커스 윤곽선을 교체할 때만 사용, 제거만 하는 것은 좋지 않다.
  - [Skip Navigation Link](https://webaim.org/techniques/skipnav/): 키보드 사용자가 페이지와 상호작용할 때만 표시되는 숨겨진 탐색 링크
  - [Accessible Landmarks](https://www.scottohara.me/blog/2018/03/03/landmarks.html): 랜드마크 엘리먼트를 통해 사용자 영역을 나눠야 함
  - 포커스 관리
    - 프로그래밍적으로 키보드 포커스를 올바른 방향으로 변경 필요(ex) 모달의 open close에 따라 reset)
    - 좋은 예시로 [react-aria-modal](https://github.com/davidtheclark/react-aria-modal)
- Mouse and pointer events
  - 마우스 혹은 포인터 이벤트로 노출된 모든 기능을 키보드만으로 사용할 수 있도록 보장해야 함
- Color contrast
  - 색 조합: [colorable](https://colorable.jxnblk.com/)
  - 색 채도 검사: [contrastchecker](https://webaim.org/resources/contrastchecker/)
- 개발 및 테스트 도구
  - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y): JSX 내 접근성 린팅, CRA에 일부 포함
  - aXe와 aXe-core, react-axe: 브라우저에서 접근성 테스트
  - 스크린 리더: Firefox의 NVDA, Safari의 VoiceOver, Internet Explorer의 JAWS, Google Chrome의 ChromeVox

### Code-Splitting

- 번들링: 여러 파일을 하나로 병합한 번들된 파일을 웹 페이지에 포함하여 한 번에 전체 앱을 로드(Webpack, Rollup, Browserify 등)
- 코드 분할(Code-Splitting): 규모가 커졌을 때 런타임에서 동적으로 번들을 불러와(`import()`) 성능 향상

```ts
// src/math.ts
export function add(num1: number, num2: number) {
  return num1 + num2;
}
```

```ts
// static import
import { add } from "./math";

console.log(add(16, 26));

// dynamic import
import("./math").then((math) => {
  console.log(math.add(16, 26));
});
```

- React.lazy + Suspense

  - `React.lazy()` 인자는 동적 import를 호출하는 함수(`() => import()`), export default 된 컴포넌트만 지원
  - `Suspense` 컴포넌트 하위에 lazy 컴포넌트를 넣어 기다리는 동안 fallback 컨텐츠를 보여줌

  ```js
  import React, { Suspense } from "react";

  const OtherComponent = React.lazy(() => import("./OtherComponent"));
  const AnotherComponent = React.lazy(() => import("./AnotherComponent"));

  function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <section>
            <OtherComponent />
            <AnotherComponent />
          </section>
        </Suspense>
      </div>
    );
  }
  ```

  - Avoiding fallback

    - Suspense와 tab으로 관리되는 컴포넌트에서 처음엔 fallback으로 `Glimmer`, 전환 시에 fallback을 감추고 전의 UI(`Photos`)를 유지하고 싶다면 `startTransition`으로 시간이 걸릴 수 있는 [transtion](https://ko.reactjs.org/docs/react-api.html#transitions)이라고 React에게 알림

    ```js
    import React, { Suspense } from "react";
    import Tabs from "./Tabs";
    import Glimmer from "./Glimmer";

    const Comments = React.lazy(() => import("./Comments"));
    const Photos = React.lazy(() => import("./Photos"));

    function MyComponent() {
      const [tab, setTab] = React.useState("photos");

      function handleTabSelect(tab) {
        startTransition(() => {
          setTab(tab);
        });
      }

      return (
        <div>
          <Tabs onTabSelect={handleTabSelect} />
          <Suspense fallback={<Glimmer />}>
            {tab === "photos" ? <Photos /> : <Comments />}
          </Suspense>
        </div>
      );
    }
    ```

  - Error Boundary로 lazy 컴포넌트를 감싸면 네트워크 장애가 발생했을 때 에러를 표시하여 사용자 경험을 향상시키고 recovery를 관리할 수 있다.

- Route-based code splitting

  - 사용자는 페이지 전환에 어느 정도 시간이 걸리는 것에 익숙하고, 전체 페이지를 한번에 re-render 하는 경향이 있기 때문에 사용자와 다른 요소가 상호 작용할 가능성이 낮음

  ```js
  import React, { Suspense, lazy } from "react";
  import { BrowserRouter as Router, Routes, Route } from "react-router-dom";

  const Home = lazy(() => import("./routes/Home"));
  const About = lazy(() => import("./routes/About"));

  const App = () => (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </Router>
  );
  ```

### Context

- 단계마다 일일이 props를 넘겨주지 않고도 컴포넌트 트리 전체에 데이터를 제공
- 언제 사용해야 하는지

  - 로그인한 유저, 테마, 선호하는 언어 등을 global하게 공유해야 할 때
  - context를 사용하면 컴포넌트의 재사용성이 떨어지기 때문에 반드시 필요할 때만 쓰고, 컴포넌트 합성(props로 컴포넌트를 직접 내림)도 해결책이 될 수 있다.
    - 제어의 역전(inversion of control)을 통해 코드가 깔끔해질 수는 있지만 그만큼 상위 컴포넌트가 복잡해진다.

- API
  - `React.createContext`
    - Context 객체 생성하는 메서드, Provider로부터 현재 값을 읽음
    - 인자로 전달하는 defaultValue는 적절한 Provider를 못 찾았을 때 사용하는 값(컴포넌트를 독립적으로 테스트할 때 유용)
  - `Context.Provider`
    - context의 변화를 알리는 컴포넌트
    - `value` prop을 전달하는데 이 context를 구독한 모든 하위 컴포넌트는 value가 바뀌면 전부 re-render
      - value가 객체일 때 불필요한 re-render에 유의(value를 Provider 부모의 state로 관리하여 해결)
  - `Class.contextType`
    - 클래스 컴포넌트에 context를 property로 지정, 클래스 안에서 this.context로 활용
  - `Context.Consumer`
    - 함수 컴포넌트 안에서 context 구독하는 컴포넌트
    - 자식이 함수여야 함, `<A.Consumer>{value => // ... }</A.Consumer>`
  - `Context.displayName`
    - React DevTools에서 사용할 문자열 지정
- 하위 컴포넌트에서 context 업데이트
  - context에 함수를 담아서 전달

### Error Boundary

- UI의 일부분에 존재하는 에러가 전체 애플리케이션을 중단시켜서는 안 됨, React 16에서 도입한 하위 컴포넌트 트리의 어디에서든 자바스크립트 에러를 기록하며 깨진 컴포넌트 트리 대신 fallback UI를 보여주는 React 컴포넌트, JavaScript의 `catch {}` 구문과 유사
- 포착하지 않는 에러

  - 이벤트 핸들러

    - try-catch 이용하자

    ```js
    handleClick() {
      try {
        //
      } catch (error) {
        this.setState({ error }); // render()에서 this.state.error에 따라 if로 분기
      }
    }
    ```

  - 비동기 코드
  - SSR
  - 에러 바운더리 자체 에러

- 사용 방법
  - 클래스 컴포넌트로 생명주기 메서드인 `static getDerivedStateFromError()` 와 `componentDidCatch()` 중 하나 혹은 둘 다를 정의
  - [예시](https://codepen.io/gaearon/pen/wqvxGa?editors=0010)
- 스택 추적
  - 컴포넌트 트리의 어느 부분에서 에러가 발생했는지 파일 이름과 줄 파악 가능
  - CRA가 아닐 땐 바벨 설정에 이 [플러그인](https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source) 추가 + Production 모드에선 비활성화 해야 함
- try-catch와의 비교
  - try-catch는 명령형(imperative) 코드, React 컴포넌트는 선언적(declarative) 코드

### Forwarding Refs

- 특정 컴포넌트의 자식 중 하나의 컴포넌트에 ref 전달하는 기법

  - 보통은 필요하지 않지만, 재사용성이 높은 leaf 컴포넌트에서는 캡슐화가 불편할 수 있다.

- ref 생성 > props 전달 > forwardRef 내부의 두 번째 인자로 전달 > button이 받기

```js
// forwardRef가 없으면 ref 받지 못하고 props에서도 사용 불가
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
// ref.current는 FancyButton의 button DOM
```

- Refs 전달 in HOC

  - `ref`는 `key`처럼 prop으로 전달이 불가능하고, HOC(HigherOorder Components)에 ref 전달하면 가장 바깥쪽 컨테이너 컴포넌트에 전달된다.

  ```js
  // logProps로 wrapping 된 컴포넌트에 ref를 전달하려고 해도 LogProps 컴포넌트에 전달됨
  function logProps(WrappedComponent) {
    class LogProps extends React.Component {
      componentDidUpdate(prevProps) {
        console.log("old props:", prevProps);
        console.log("new props:", this.props);
      }

      render() {
        return <WrappedComponent {...this.props} />;
      }
    }

    return LogProps;
  }
  ```

  ```js
  function A(props) {
    return <B />;
  }

  export default logProps(A); // createRef()하고 <A ref={ref} /> 해도 A에 ref 전달 안 됨
  ```

  - 해결 방법

  ```js
  function logProps(WrappedComponent) {
    class LogProps extends React.Component {
      // ...

      render() {
        const { forwardedRef, ...rest } = this.props;

        // forwardRef를 wrapping할 컴포넌트의 ref로 전달
        return <WrappedComponent ref={forwardedRef} {...rest} />;
      }
    }

    // React.forwardRef로 함수의 return부를 감싸고 forwardref로 받음
    return React.forwardRef((props, ref) => {
      return <LogProps {...props} forwardedRef={ref} />;
    });
  }
  ```

- React.forwardedRef가 받는 렌더링 함수에 익명의 화살표 함수 대신 함수 선언식을 이용하면 DevTools에 이름 표기 가능하다.

### Fragment

- DOM에 별도의 노드를 추가하지 않고 여러 자식을 그룹화
- key prop을 줘야 할 떄는 `<React.Fragment>`

### Higher-Order Components

- 컴포넌트 로직을 재사용하는 React의 패턴, 컴포넌트를 가져와 새 컴포넌트를 반환하는 **함수**
  - Redux의 `connect`, Relay의 `createFragmentContainer` 등
- 고차 컴포넌트는 side effect가 없는 순수 함수
- 원본 컴포넌트를 변형하지 말자 === HOC 함수 안에서 원본을 return 하는 일을 할 일이 없다.
  - prototype에 변형을 가하면 HOC가 override 됨에 유의
  - 변형(mutation) 대신 컨테이너 컴포넌트로 감싸자
- HOC와 컨테이너 컴포넌트의 차이
  - HOCs use containers as part of their implementation
  - 컨테이너는 자식과 관심사를 분리하는 것이고 state에 대한 관리를 하지 않는다. [링크](https://www.quora.com/What-is-the-difference-between-a-HOC-and-a-container-component-in-ReactJS)

## API REFERENCE

## HOOKS

## TESTING

## 그 외
