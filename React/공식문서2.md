# [React 공식문서](https://ko.reactjs.org/docs/getting-started.html) 보며 몰랐던 부분 찾기

## ADVANCED GUIDES

### Accessibility(접근성)

- 모든 사용자가 사용할 수 있도록 웹사이트를 디자인, 개발해야함(보조과학기술(assistive technology)들이 웹페이지들을 해석할 수 있도록 접근성을 갖추는 것이 필요)
- 필요한 지침
  - [WCGA](https://www.w3.org/WAI/standards-guidelines/wcag/)
  - JavaScript 위젯 기술 [WAI-ARIA](https://www.w3.org/WAI/standards-guidelines/aria/)
    - JSX에서는 `aria-*` HTML attribute를 지원
- Semantic HTML
  - 정보의 의미가 강조되는 HTML 태그 사용하자
- Accessible Forms
  - 스크린 리더를 사용하는 사용자를 위해 설명이 담긴 label로 폼 컨트롤을 감싸야 함
    - [W3C의 라벨링](https://www.w3.org/WAI/tutorials/forms/labels/)
    - [WebAIM의 라벨링](https://webaim.org/techniques/forms/controls)
  - 스크린 리더에 오류 문구를 적절하게 노출시켜야 함
- Focus Control
  - 모든 웹 애플리케이션은 키보드만 사용하여 모든 동작을 할 수 있어야 함
  - `outline: 0`은 포커스 윤곽선을 교체할 때만 사용, 제거만 하는 것은 좋지 않다.
  - [Skip Navigation Link](https://webaim.org/techniques/skipnav/): 키보드 사용자가 페이지와 상호작용할 때만 표시되는 숨겨진 탐색 링크
  - [Accessible Landmarks](https://www.scottohara.me/blog/2018/03/03/landmarks.html): 랜드마크 엘리먼트를 통해 사용자 영역을 나눠야 함
  - 포커스 관리
    - 프로그래밍적으로 키보드 포커스를 올바른 방향으로 변경 필요(ex) 모달의 open close에 따라 reset)
    - 좋은 예시로 [react-aria-modal](https://github.com/davidtheclark/react-aria-modal)
- Mouse and pointer events
  - 마우스 혹은 포인터 이벤트로 노출된 모든 기능을 키보드만으로 사용할 수 있도록 보장해야 함
- Color contrast
  - 색 조합: [colorable](https://colorable.jxnblk.com/)
  - 색 채도 검사: [contrastchecker](https://webaim.org/resources/contrastchecker/)
- 개발 및 테스트 도구
  - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y): JSX 내 접근성 린팅, CRA에 일부 포함
  - aXe와 aXe-core, react-axe: 브라우저에서 접근성 테스트
  - 스크린 리더: Firefox의 NVDA, Safari의 VoiceOver, Internet Explorer의 JAWS, Google Chrome의 ChromeVox

### Code-Splitting

- 번들링: 여러 파일을 하나로 병합한 번들된 파일을 웹 페이지에 포함하여 한 번에 전체 앱을 로드(Webpack, Rollup, Browserify 등)
- 코드 분할(Code-Splitting): 규모가 커졌을 때 런타임에서 동적으로 번들을 불러와(`import()`) 성능 향상

```ts
// src/math.ts
export function add(num1: number, num2: number) {
  return num1 + num2;
}
```

```ts
// static import
import { add } from "./math";

console.log(add(16, 26));

// dynamic import
import("./math").then((math) => {
  console.log(math.add(16, 26));
});
```

- React.lazy + Suspense

  - `React.lazy()` 인자는 동적 import를 호출하는 함수(`() => import()`), export default 된 컴포넌트만 지원
  - `Suspense` 컴포넌트 하위에 lazy 컴포넌트를 넣어 기다리는 동안 fallback 컨텐츠를 보여줌

  ```js
  import React, { Suspense } from "react";

  const OtherComponent = React.lazy(() => import("./OtherComponent"));
  const AnotherComponent = React.lazy(() => import("./AnotherComponent"));

  function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <section>
            <OtherComponent />
            <AnotherComponent />
          </section>
        </Suspense>
      </div>
    );
  }
  ```

  - Avoiding fallback

    - Suspense와 tab으로 관리되는 컴포넌트에서 처음엔 fallback으로 `Glimmer`, 전환 시에 fallback을 감추고 전의 UI(`Photos`)를 유지하고 싶다면 `startTransition`으로 시간이 걸릴 수 있는 [transtion](https://ko.reactjs.org/docs/react-api.html#transitions)이라고 React에게 알림

    ```js
    import React, { Suspense } from "react";
    import Tabs from "./Tabs";
    import Glimmer from "./Glimmer";

    const Comments = React.lazy(() => import("./Comments"));
    const Photos = React.lazy(() => import("./Photos"));

    function MyComponent() {
      const [tab, setTab] = React.useState("photos");

      function handleTabSelect(tab) {
        startTransition(() => {
          setTab(tab);
        });
      }

      return (
        <div>
          <Tabs onTabSelect={handleTabSelect} />
          <Suspense fallback={<Glimmer />}>
            {tab === "photos" ? <Photos /> : <Comments />}
          </Suspense>
        </div>
      );
    }
    ```

  - Error Boundary로 lazy 컴포넌트를 감싸면 네트워크 장애가 발생했을 때 에러를 표시하여 사용자 경험을 향상시키고 recovery를 관리할 수 있다.

- Route-based code splitting

  - 사용자는 페이지 전환에 어느 정도 시간이 걸리는 것에 익숙하고, 전체 페이지를 한번에 re-render 하는 경향이 있기 때문에 사용자와 다른 요소가 상호 작용할 가능성이 낮음

  ```js
  import React, { Suspense, lazy } from "react";
  import { BrowserRouter as Router, Routes, Route } from "react-router-dom";

  const Home = lazy(() => import("./routes/Home"));
  const About = lazy(() => import("./routes/About"));

  const App = () => (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </Router>
  );
  ```

### Context

### Error Boundary

- UI의 일부분에 존재하는 에러가 전체 애플리케이션을 중단시켜서는 안 됨, React 16에서 도입한 하위 컴포넌트 트리의 어디에서든 자바스크립트 에러를 기록하며 깨진 컴포넌트 트리 대신 fallback UI를 보여주는 React 컴포넌트, JavaScript의 `catch {}` 구문과 유사
- 포착하지 않는 에러

  - 이벤트 핸들러

    - try-catch 이용하자

    ```js
    handleClick() {
      try {
        //
      } catch (error) {
        this.setState({ error }); // render()에서 this.state.error에 따라 if로 분기
      }
    }
    ```

  - 비동기 코드
  - SSR
  - 에러 바운더리 자체 에러

- 사용 방법
  - 클래스 컴포넌트로 생명주기 메서드인 `static getDerivedStateFromError()` 와 `componentDidCatch()` 중 하나 혹은 둘 다를 정의
  - [예시](https://codepen.io/gaearon/pen/wqvxGa?editors=0010)
- 스택 추적
  - 컴포넌트 트리의 어느 부분에서 에러가 발생했는지 파일 이름과 줄 파악 가능
  - CRA가 아닐 땐 바벨 설정에 이 [플러그인](https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source) 추가 + Production 모드에선 비활성화 해야 함
- try-catch와의 비교
  - try-catch는 명령형(imperative) 코드, React 컴포넌트는 선언적(declarative) 코드

## API REFERENCE

## HOOKS

## TESTING

## 그 외
