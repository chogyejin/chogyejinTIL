# [React 공식문서](https://ko.reactjs.org/docs/getting-started.html) 보며 몰랐던 부분 찾기

## INSTALLATION

### 점진적으로 코드 도입 가능 [참고링크](https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605)

1. HTML 파일에 DOM(div) 추가

```html
<div id="like_button_container"></div>
```

2. script 태그 추가

```html
<body>
  <!-- React 실행 -->
  <!-- development.js 혹은 production.min.js -->
  <script
    src="https://unpkg.com/react@18/umd/react.development.js"
    crossorigin
  ></script>
  <script
    src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    crossorigin
  ></script>
  <!-- 컴포넌트 실행 -->
  <script src="like_button.js"></script>
</body>
```

3. 컴포넌트 만들기

```js
// like_button.js
const e = React.createElement;
// ...
const domContainer = document.querySelector("#like_button_container");
const root = ReactDOM.createRoot(domContainer);
root.render(e(LikeButton));
```

## MAIN CONCEPTS

### 지식 수준 가정

- [JS overview](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Overview)
- [modern_js](https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c)
  - `var`, `let`, `const`
  - 클래스
  - arrow function

### JSX

- JavaScript를 확장한 문법, 객체임

```js
const element = <h1 className="greeting">Hello, world!</h1>;
const element = React.createElement(
  "h1",
  { className: "greeting" },
  "Hello, world!"
);
const element = {
  type: "h1",
  props: {
    className: "greeting",
    children: "Hello, world!",
  },
};
```

- 컴포넌트: 마크업 + 로직
- HTML보단 JavaScript에 가깝기에 camelCase 사용하자
- 애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않음 => XSS(cross-site-scripting) 방지 가능

### Element

- React apps의 가장 작은 단위
- 컴포넌트의 구성 요소
- React 엘리먼트는 불변객체
  - UI를 업데이트하려면 새로운 엘리먼트를 생성하고 이를 root.render()의 인자로 전달하는 것
- React DOM은 해당 엘리먼트와 그 자식 엘리먼트를 이전의 엘리먼트와 비교하고 DOM을 원하는 상태로 만드는데 필요한 경우에만 DOM을 업데이트

### Components와 Props

- 컴포넌트: `props`라고 하는 임의의 입력을 받은 후, 화면에 어떻게 표시되는지를 기술하는 `React 엘리먼트`를 반환
  - props: React가 사용자 정의 컴포넌트로 작성한 엘리먼트를 발견하면 **JSX 어트리뷰트**와 **자식**을 해당 컴포넌트에 전달, 이 단일 객체가 props
    - props의 이름은 사용될 context가 아닌 컴포넌트 자체의 관점에서 짓는 것을 권장(`author` => `user`)

```js
// 함수 컴포넌트
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
// 클래스 컴포넌트
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

- 컴포넌트 추출: 재사용 가능한 컴포넌트를 만드는 것은 규모가 커질수록 두각을 나타냄
  - UI 재사용(Button, Avatar 등)
  - UI 일부가 복잡할 때(App, Comment 등)
- Props는 읽기 전용
  - 컴포넌트에서 자체 props를 수정하려 하면 안 됨 === 순수 함수\*처럼 동작해야 함
  - 순수 함수: 동일한 입력값에 대해 동일한 출력을 갖는 함수

### State

- The Data Flows Down
  - 햐향식, 단방향식 데이터 흐름
  - 부모 컴포넌트나 자식 컴포넌트 모두 특정 컴포넌트가 유상태인지 또는 무상태인지 알 수 없고, 그들이 함수나 클래스로 정의되었는지에 대해서 관심을 가질 필요가 없음
  - 모든 state는 특정 컴포넌트가 소유하며 자신의 아래에 있는 컴포넌트에만 영향을 미침

### 이벤트 처리

- HTML에선 문자열이지만, JSX에선 함수 자체를 넘김
- React 이벤트는 합성 이벤트(synthetic event)로 브라우저 고유 이벤트와 정확히 동일하게 동작하지는 않음
- 클래스 컴포넌트에서 메서드(`handleClick`) 바인딩
  - JavaScript에서 클래스 메서드는 기본적으로 [바인딩](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)되어 있지 않음

```js
this.x = 9;
var module = {
  x: 81,
  getX: function () {
    return this.x;
  },
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX(); // 9, 함수가 전역 스코프에서 호출됐음
```

```js
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };

    // 바인딩하지 않으면 JSX의 this가 undefined
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState((prevState) => ({
      isToggleOn: !prevState.isToggleOn,
    }));
  }

  render() {
    return (
      // this.handleClick과 같이 ()를 사용하지 않았기 때문에 바인딩 필요
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? "ON" : "OFF"}
      </button>
    );
  }
}
```

- 바인딩을 하기 싫다면?

  - public class fields syntax: 간단, 실험적, 각 인스턴스마다 새로 필드 생성, [링크](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#public_instance_fields)

  ```js
  class LoggingButton extends React.Component {
    handleClick = () => {
      console.log("this is:", this);
    };

    render() {
      return <button onClick={this.handleClick}>Click me</button>;
    }
  }
  ```

  - arrow function: LoggingButton이 렌더링될 때마다 다른 콜백 생성, 콜백이 하위 컴포넌트에 props로 전달된다면 계속 새로운 하위 컴포넌트를 생성할 수 있음(constructor에서 bind하거나 public class fields 문법 권장)

  ```js
  class LoggingButton extends React.Component {
    handleClick() {
      console.log("this is:", this);
    }

    render() {
      return <button onClick={() => this.handleClick()}>Click me</button>;
    }
  }
  ```

### Conditional Rendering

- stateful(유상태) component: state를 가진 컴포넌트
- 상태에 맞게 엘리먼트를 가진 변수를 렌더링하거나 컴포넌트를 렌더링

```js
function LoginButton(props) {
  return <button onClick={props.onClick}>Login</button>;
}

function LogoutButton(props) {
  return <button onClick={props.onClick}>Logout</button>;
}

class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = { isLoggedIn: false };
  }

  handleLoginClick() {
    this.setState({ isLoggedIn: true });
  }

  handleLogoutClick() {
    this.setState({ isLoggedIn: false });
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button; // 여기에 엘리먼트 대입

    // isLoggedIn에 따라 분기, props로 LoginControl의 handler를 내려줌
    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    // <Greeting />을 렌더링, 상태에 따라 {button} (<LoginButton /> or <LogoutButton />) 렌더링
    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<LoginControl />);
```

- 컴포넌트 내에서 JSX를 return 하기 전에 `return null`로 컴포넌트 렌더링을 막는다.

### Key

- 리스트를 렌더링할 때 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 도움
- 고유하게 식별할 수 있는 문자열 권장(ex) 데이터의 id)
  - 항목의 순서가 바뀔 가능성이 있을 때 index를 key로 사용하면 성능 저하나 state 관련 문제 발생 가능성 생김([key 문제](https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318))
  - 다음과 같은 상황에선 index를 써도 됨
    1. 리스트와 각 아이템이 정적이고 계산되거나 변하지 않을 때
    2. 아이템에 id가 없을 때
    3. 리스트가 절대 재정렬되거나 필터링 되지 않을 때
- 배열 안의 형제(siblings) 사이에서만 고유하면 된다.
- props.key로 읽지 못한다.
- 별도의 변수 vs JSX 내에 `map()` 포함: map이 많아지면 별도 컴포넌트로 추출하자

  ```js
  // listItmes, 가독성 증가
  function NumberList(props) {
    const numbers = props.numbers;
    const listItems = numbers.map((number) => (
      <ListItem key={number.toString()} value={number} />
    ));
    return <ul>{listItems}</ul>;
  }

  // JSX + map(), 더 깔끔함,
  function NumberList(props) {
    const numbers = props.numbers;
    return (
      <ul>
        {numbers.map((number) => (
          <ListItem key={number.toString()} value={number} />
        ))}
      </ul>
    );
  }
  ```

### Forms

- controlled component: React에 의해 값이 제어되는 input form element(`<input>`, `<textarea>`, `<select>`)
  - 사용자 입력에서 발생하는 이벤트(`onChange`)를 제어해서 HTML 엘리먼트에 들어온 정보를 컴포넌트의 state로 저장하고, state를 기반으로 엘리먼트를 다시 re-rendering 시켜서 엘리먼트의 value attribute를 변경시키는 방식, state는 single source of truth가 됨([참고 링크](https://velog.io/@dolarge/React-Controlled-Componenet-vs-Unconterolled-Componenet))
- 다중 input 제어

  ```js
  class Reservation extends React.Component {
    constructor(props) {
      // ...
    }

    handleInputChange(event) {
      const target = event.target;
      const value = target.type === "checkbox" ? target.checked : target.value;
      const name = target.name;

      this.setState({
        [name]: value, // ES6 computed property name
      });
    }

    render() {
      return (
        <input
          name="isGoing"
          type="checkbox"
          checked={this.state.isGoing}
          onChange={this.handleInputChange}
        />
        <input
          name="numberOfGuests"
          type="number"
          value={this.state.numberOfGuests}
          onChange={this.handleInputChange}
        />
      );
    }
  }
  ```

- 데이터가 변하는 모든 곳에서 event handler를 작성하는 게 무리같다면 uncontrolled component도 대안이 될 수 있다.
  - uncontrolled component는 자체 state를 가질 수 있는 태그가 자식 엘리먼트일 때 그 값을 직접 제어하는 것이 아니고 참조(ref)하여 사용함
- 문서에서는 form 관련 라이브러리로 [Formik](https://formik.org/)을 추천하지만, controlled component 방식으로 불필요한 re-rendering을 유발할 수 있기 때문에 클래스 컴포넌트가 아니라면 uncontrolled component 방식으로 구현된 [React-Hook-Form](https://react-hook-form.com/)이 매력적으로 보인다.
  - [장단점 비교](https://blog.logrocket.com/react-hook-form-vs-formik-comparison/)
  - [npm trends 비교](https://npmtrends.com/formik-vs-react-hook-form)

## ADVANCED GUIDES

## API REFERENCE

## HOOKS

## TESTING

## 그 외
